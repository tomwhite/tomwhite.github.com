---
layout: post
title: RPC and Serialization with Hadoop, Thrift, and Protocol Buffers
date: '2008-07-08T10:43:00.012+01:00'
author: Tom White
tags:
- MapReduce
- Thrift
- Serialization
- Hadoop
- RPC
modified_time: '2008-07-08T14:03:40.052+01:00'
blogger_id: tag:blogger.com,1999:blog-8898949683610477251.post-2466668333674859777
blogger_orig_url: http://www.tom-e-white.com/2008/07/rpc-and-serialization-with-hadoop.html
---

Hadoop and related projects like Thrift provide a choice of protocols and formats for doing RPC and serialization. In this post I'll briefly run through them and explain where they came from, how they relate to each other and how Google's <a href="http://google-code-updates.blogspot.com/2008/07/protocol-buffers-our-serialized.html">newly released Protocol Buffers</a> might fit in.<br /><br /><h3>RPC and Writables</h3>Hadoop has its own RPC mechanism that dates back to when Hadoop was a part of <a href="http://lucene.apache.org/nutch/">Nutch</a>. It's used throughout Hadoop as the mechanism by which daemons talk to each other. For example, a <code>DataNode</code> communicates with the <code>NameNode</code>  using the RPC interface <code>DatanodeProtocol</code>.<br /><br />Protocols are defined using Java interfaces whose arguments and return types are primitives, Strings, Writables, or arrays. These types can all be serialized using Hadoop's specialized serialization format, based on <a href="http://hadoop.apache.org/core/docs/current/api/org/apache/hadoop/io/Writable.html">Writable</a>. Combined with the magic of <a href="http://java.sun.com/j2se/1.3/docs/guide/reflection/proxy.html">Java dynamic proxies</a>, we get a simple RPC mechanism which for the caller appears to be a Java interface.<br /><br /><h3>MapReduce and Writables</h3>Hadoop uses Writables for another, quite different, purpose: as a serialization format for MapReduce programs. If you've ever written a Hadoop MapReduce program you will have used Writables for the key and value types. For example:<br /><pre><code><br /><br />public class MapClass<br />implements Mapper&lt;LongWritable, Text, Text, IntWritable&gt; {<br /><br />// ...<br /><br />}<br /><br /></code></pre>(<code>Text</code> is just a Writable version of Java <code>String</code>.)<br /><br />The primary benefit of using Writables is in their efficiency. Compared to <a href="http://java.sun.com/j2se/1.4.2/docs/guide/serialization/index.html">Java serialization</a>, which would have been an obvious alternative choice, they have a more compact representation. Writables don't store their type in the serialized representation, since at the point of deserialization it is known which type is expected. For the MapReduce code above, the input key is a <code>LongWritable</code>, so an empty <code>LongWritable</code> instance is asked to populate itself from the input data stream.<br /><br /><h3>More flexible MapReduce</h3>There are downsides of having to use Writables for MapReduce types, however. For a newcomer to Hadoop it's another hurdle: something else to learn ("why can't I just use a String?"). More seriously, perhaps, is that it's hard to use different binary storage formats for MapReduce input and output. For example, Apache Thrift (see below) is an increasingly popular way of storing binary data. It's possible, but cumbersome and inefficient, to read or write Thrift data from MapReduce.<br /><br />From Hadoop 0.17.0 onwards <a href="https://issues.apache.org/jira/browse/HADOOP-1986">you no longer have to use Writables for key and value types in MapReduce programs</a>. You can use any serialization framework. (Note that this is change is completely independent of Hadoop's RPC mechanism, which still uses Writables - and can only use Writables - as its on-wire format.) So it's easier to use Thrift types, say, throughout your MapReduce program. Or you can even use Java serialization (with <a href="https://issues.apache.org/jira/browse/HADOOP-3566">some limitations</a> which will be fixed). What's more, you can add your own serialization framework if you like.<br /><br /><h3>Record I/O, Thrift and Protocol Buffers<br /></h3>Another problem with Writables, at least for the MapReduce programmer, is that creating new types is a burden. You have to implement the Writable interface, which means designing the on-wire format, and writing two methods: one to write the data in that format and one to read it back.<br /><br />Hadoop's Record I/O was created to solve this problem. You write a definition of your types using a record definition language, then run a record compiler to generate Java source code representations of your types. All Record I/O types are Writable, so they plug into Hadoop very easily. As a bonus, you can generate bindings for other languages, so it's easy to read your data files from other programs.<br /><br />For whatever reason, Record I/O never really took off. It's used in <a href="http://zookeeper.sourceforge.net/">ZooKeeper</a>, but that's about it (and ZooKeeper will <a href="http://publists.facebook.com/pipermail/thrift/2008-January/000330.html">move away</a> from it someday). Momentum has switched to <a href="http://incubator.apache.org/thrift/">Thrift</a> (from Facebook, now in the Apache Incubator), which offers a very similar proposition, but in more languages. Thrift also makes it easy to build a (cross-language) RPC mechanism.<br /><br />Yesterday, Google open sourced <a href="http://code.google.com/apis/protocolbuffers/">Protocol Buffers</a>, its "language-neutral, platform-neutral, extensible mechanism for serializing structured data". Record I/O, Thrift and Protocol Buffers are really solving the same problem, so it will be interesting to see how this develops. Of course, since we're talking about persistent data formats, nothing's going to go away in the short or medium term while people have significant amounts of data locked up in these formats.<br /><br />That's why it makes sense to add support in Hadoop for MapReduce using Thrift and Protocol Buffers: so people can process data in the format they have it in. This will be a relatively simple addition.<br /><br /><h3>What Next?</h3>For RPC, where a message is short-lived, changing the mechanism is more viable in the short term. Going back to Hadoop's RPC mechanism, now that both Thrift and Protocol Buffers offer an alternative, it may well be time to evaluate them to see if either can offer a performance boost. It would be a big job to retrofit RPC in Hadoop with another implementation, but if there are significant performance gains to be had, then it would be worth doing.