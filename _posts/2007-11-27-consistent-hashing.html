---
layout: post
title: Consistent Hashing
date: '2007-11-27T17:26:00.000Z'
author: Tom White
tags:
- Distributed Systems
- Hashing
modified_time: '2007-11-27T17:36:44.531Z'
thumbnail: http://2.bp.blogspot.com/_IhqEHw4_Ick/Rz9cjSPnAEI/AAAAAAAAAA4/hc2tot8SWVw/s72-c/consistent_hashing_1.png
blogger_id: tag:blogger.com,1999:blog-8898949683610477251.post-8023602409631923584
blogger_orig_url: http://www.tom-e-white.com/2007/11/consistent-hashing.html
---

I've bumped into consistent hashing a couple of times lately. The paper that introduced the idea (<a href="http://citeseer.ist.psu.edu/karger97consistent.html">Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web</a> by <a href="http://people.csail.mit.edu/karger/">David Karger</a> <i>et al</i>) appeared ten years ago, although recently it seems the idea has quietly been finding its way into more and more services, from Amazon's <a href="http://www.allthingsdistributed.com/2007/10/amazons_dynamo.html">Dynamo</a> to <a href="http://www.danga.com/memcached/">memcached</a> (courtesy of <a href="http://www.last.fm/">Last.fm</a>). So what is consistent hashing and why should you care?<br /><br />The need for consistent hashing arose from limitations experienced while running collections of caching machines - web caches, for example. If you have a collection of <i>n</i> cache machines then a common way of load balancing across them is to put object <i>o</i> in cache machine number <i>hash(o)</i> mod <i>n</i>. This works well until you add or remove cache machines (for whatever reason), for then <i>n</i> changes and <i>every object is hashed to a new location</i>. This can be catastrophic since the originating content servers are swamped with requests from the cache machines. It's as if the cache suddenly disappeared. Which it has, in a sense. (This is why you should care - consistent hashing is needed to avoid swamping your servers!)<br /><br />It would be nice if, when a cache machine was added, it took its fair share of objects from all the other cache machines. Equally, when a cache machine was removed, it would be nice if its objects were shared between the remaining machines. This is exactly what consistent hashing does - <i>consistently</i> maps objects to the same cache machine, as far as is possible, at least.<br /><br />The basic idea behind the consistent hashing algorithm is to hash both objects and caches using the same hash function. The reason to do this is to map the cache to an interval, which will contain a number of object hashes. If the cache is removed then its interval is taken over by a cache with an adjacent interval. All the other caches remain unchanged.<br /><h3>Demonstration</h3>Let's look at this in more detail. The hash function actually maps objects and caches to a number range. This should be familiar to every Java programmer - the <code>hashCode</code> method on <code>Object</code> returns an <code>int</code>, which lies in the range -2<sup>31</sup> to  2<sup>31</sup>-1. Imagine mapping this range into a circle so the values wrap around. Here's a picture of the circle with a number of objects (1, 2, 3, 4) and caches (A, B, C) marked at the points that they hash to (based on a diagram from <a href="http://www8.org/w8-papers/2a-webserver/caching/paper2.html">Web Caching with Consistent Hashing</a> by David Karger <i>et al</i>):<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_IhqEHw4_Ick/Rz9cjSPnAEI/AAAAAAAAAA4/hc2tot8SWVw/s1600-h/consistent_hashing_1.png"><img style="cursor: pointer;" src="http://2.bp.blogspot.com/_IhqEHw4_Ick/Rz9cjSPnAEI/AAAAAAAAAA4/hc2tot8SWVw/s400/consistent_hashing_1.png" alt="" id="BLOGGER_PHOTO_ID_5133923861488140354" border="0" /></a><br /><br />To find which cache an object goes in, we move clockwise round the circle until we find a cache point. So in the diagram above, we see object 1 and 4 belong in cache A, object 2 belongs in cache B and object 3 belongs in cache C. Consider what happens if cache C is removed: object 3 now belongs in cache A, and all the other object mappings are unchanged. If then another cache D is added in the position marked it will take objects 3 and 4, leaving only object 1 belonging to A.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_IhqEHw4_Ick/Rz9cwyPnAFI/AAAAAAAAABA/aW5zxmOIIN0/s1600-h/consistent_hashing_2.png"><img style="cursor: pointer;" src="http://4.bp.blogspot.com/_IhqEHw4_Ick/Rz9cwyPnAFI/AAAAAAAAABA/aW5zxmOIIN0/s400/consistent_hashing_2.png" alt="" id="BLOGGER_PHOTO_ID_5133924093416374354" border="0" /></a><br /><br />This works well, except the size of the intervals assigned to each cache is pretty hit and miss. Since it is essentially random it is possible to have a very non-uniform distribution of objects between caches. The solution to this problem is to introduce the idea of "virtual nodes", which are replicas of cache points in the circle. So whenever we add a cache we create a number of points in the circle for it.<br /><br />You can see the effect of this in the following plot which I produced by simulating storing 10,000 objects in 10 caches using the code described below. On the x-axis is the number of replicas of cache points (with a logarithmic scale). When it is small, we see that the distribution of objects across caches is unbalanced, since the standard deviation as a percentage of the mean number of objects per cache (on the y-axis, also logarithmic) is high. As the number of replicas increases the distribution of objects becomes more balanced. This experiment shows that a figure of one or two hundred replicas achieves an acceptable balance (a standard deviation that is roughly between 5% and 10% of the mean).<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_IhqEHw4_Ick/Rz9daCPnAGI/AAAAAAAAABI/xjtbuG8Knx0/s1600-h/ch-graph.png"><img style="cursor: pointer;" src="http://1.bp.blogspot.com/_IhqEHw4_Ick/Rz9daCPnAGI/AAAAAAAAABI/xjtbuG8Knx0/s400/ch-graph.png" alt="" id="BLOGGER_PHOTO_ID_5133924802085978210" border="0" /></a><br /><h3>Implementation</h3>For completeness here is a simple implementation in Java. In order for consistent hashing to be effective it is important to have a hash function that <a href="http://problemsworthyofattack.blogspot.com/2007/10/mixing-with-md5.html">mixes</a> well. Most implementations of <code>Object</code>'s <code>hashCode</code> do <i>not</i> mix well - for example, they typically produce a restricted number of small integer values - so we have a <code>HashFunction</code> interface to allow a custom hash function to be used. MD5 hashes are recommended here.<br /><br /><pre><br />import java.util.Collection;<br />import java.util.SortedMap;<br />import java.util.TreeMap;<br /><br />public class ConsistentHash&lt;T&gt; {<br /><br />  private final HashFunction hashFunction;<br />  private final int numberOfReplicas;<br />  private final SortedMap&lt;Integer, T&gt; circle =<br />    new TreeMap&lt;Integer, T&gt;();<br /><br />  public ConsistentHash(HashFunction hashFunction,<br />    int numberOfReplicas, Collection&lt;T&gt; nodes) {<br /><br />    this.hashFunction = hashFunction;<br />    this.numberOfReplicas = numberOfReplicas;<br /><br />    for (T node : nodes) {<br />      add(node);<br />    }<br />  }<br /><br />  public void add(T node) {<br />    for (int i = 0; i &lt; numberOfReplicas; i++) {<br />      circle.put(hashFunction.hash(node.toString() + i),<br />        node);<br />    }<br />  }<br /><br />  public void remove(T node) {<br />    for (int i = 0; i &lt; numberOfReplicas; i++) {<br />      circle.remove(hashFunction.hash(node.toString() + i));<br />    }<br />  }<br /><br />  public T get(Object key) {<br />    if (circle.isEmpty()) {<br />      return null;<br />    }<br />    int hash = hashFunction.hash(key);<br />    if (!circle.containsKey(hash)) {<br />      SortedMap&lt;Integer, T&gt; tailMap =<br />        circle.tailMap(hash);<br />      hash = tailMap.isEmpty() ?<br />             circle.firstKey() : tailMap.firstKey();<br />    }<br />    return circle.get(hash);<br />  } <br /><br />}<br /></pre><br /><br />The circle is represented as a sorted map of integers, which represent the hash values, to caches (of type <code>T</code> here).<br />When a <code>ConsistentHash</code> object is created each node is added to the circle map a number of times (controlled by <code>numberOfReplicas</code>). The location of each replica is chosen by hashing the node's name along with a numerical suffix, and the node is stored at each of these points in the map.<br /><br />To find a node for an object (the <code>get</code> method), the <i>hash value of the object</i> is used to look in the map. Most of the time there will not be a node stored at this hash value (since the hash value space is typically much larger than the number of nodes, even with replicas), so the next node is found by looking for the first key in the tail map. If the tail map is empty then we wrap around the circle by getting the first key in the circle.<br /><h3>Usage</h3>So how can you use consistent hashing? You are most likely to meet it in a library, rather than having to code it yourself. For example, as mentioned above, memcached, a distributed memory object caching system, now has clients that support consistent hashing. Last.fm's <a href="http://www.audioscrobbler.net/development/ketama/">ketama</a> by <a href="http://www.last.fm/user/RJ/">Richard Jones</a> was the first, and there is now a <a href="http://bleu.west.spy.net/%7Edustin/projects/memcached/">Java implementation</a> by <a href="http://bleu.west.spy.net/%7Edustin/">Dustin Sallings</a> (which inspired my simplified demonstration implementation above). It is interesting to note that it is only the client that needs to implement the consistent hashing algorithm - the memcached server is unchanged. Other systems that employ consistent hashing include <a href="http://pdos.csail.mit.edu/chord/">Chord</a>, which is a distributed hash table implementation, and Amazon's Dynamo, which is a key-value store (not available outside Amazon).